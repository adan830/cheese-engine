With mutable text:
Clicking somewhere
Clicking beyond the end of a line should move the cursor to the end of that line
Clicking below the last line should move the cursor to the last line

Scrolling text in the console, you can scroll up so that the top line of text goes 1 line below the bottom of the text box
Similarly, scrolling buttons can scroll so that it goes 2 lines below
Is it always exactly this wrong?

Scroll bar for scrolling buttons and text

Add text colors to buttons, windows, tooltips, and toasts

-----------------------------------------------
Mod support
Need to disable this whole system on Android

UPDATE:
Phase 1: Use a virtual file system for all data file loading, with pak file support
Duplicate files are replaced in the virtual file system as it is setting up
4 places to look for files:
Base data directory, pak files
Base data directory, loose files
Home data directory, pak files
Home data directory, loose files
Files are looked at within each place in alphabetical order (use same sorting as checksum thing)
Rebuild VFS each time it is needed? Or build it once at program start? Or rebuild at certain times?
Does checksum system need to be updated at all? Probably just need to add to runtime check so it includes the home data dir
Phase 2 (maybe?): add concept of base game + current mod
The base game is the actual game
The "current mod" is the currently selected mod, if any
The 4 places above would all be checked for the base game and then for the current game
The checksum system would need to be updated to include these changes
This would allow for mods to be distributed in self-contained directories
Entire mods could exist in the base or home directory as separate mods
Probably structured like this:
base game --> base/data
current mod choices --> base/mods/<mod name>
base game --> home/data
current mod choices --> home/mods/<mod name>
A simple string can be a runtime-only option that determines the current mod
An empty string is no mod, otherwise it is the name of the mod currently selected
Menu in-game should show base game + all available mods, and allow for selection of base game or a mod
Selecting one of these changes the runtime mod option, and reloads EVERYTHING

Might want to move autoexec.cfg into the data dir, so it is tied to either the base game or a mod

When changing mods, pretty much the entire game needs to be completely restarted

A command line option should be added for starting up with a specific mod

Might need to consider save location when building vfs
If it is local, ignore home stuff

Two types of vfs uses:
1. Looking for a specific file
In this case simply look for file in each possible location, starting with the highest priority
When (if) found, immediately return this file (the actual file itself, I.e. load it)
2. Listing what files exist in a directory
Look through each location, starting with the lowest priority
Build a list of all files
If a duplicate file is found, replace its entry in the list
When done looking in each location, return the list (of virtual files)

No list or whatever needs to be maintained
The vfs actually loads files and gives pointers to them in memory
It needs a function for closing an opened file
The user of the vfs is responsible for the pointers received from the vfs
For a text data file, the engine would request the file from the vfs, the vfs would load the file and return a pointer to it, the engine would read the file (which is now in memory) and use it for whatever, the engine would tell the vfs to close the file.
The engine could get a list of all text data files to load by requesting a file list from the root data directory from the vfs

The remainder of this section about modding is mostly/entirely wrong now:

For at least most objects created from data files, add code for overriding them
I.e., if a data file has created a font with a certain name, and later a data file tries to create
a font with the same name, it doesn't actually create a new font.
Instead, its points to the already existing object, and each entry simply changes the corresponding
entry in the object (obviously the name entry can't be changed)

A problem arises when you have objects within objects, like a button in a window
(in fact I think the window is the ONLY object like this in the template)
These child objects don't have names, so they can't just be overridden
An obvious solution is that for these kinds of objects, it works differently and
trying to create a same-named object just erases the old one and creates a whole new one
I like this, other than the fact that it is inconsistent with the rest of the objects :-(

For this system to work, I need to ensure that all data files are
read in alphabetical order (just like for the checksum)
Since engine is a special case and doesn't create an object anyway,
it might be even easier to make it work with this system

I should make sure that the engine ONLY loads supported file formats for images/sounds/music(.png and .ogg)
It should just ignore other formats (is this a problem for the .bmp icon(s)?)

Now, a mods directory goes in the home directory
A mod is defined by being a sub-directory of the mods directory
Any files in the mods dir are ignored
Within a mod dir, it should be arranged exactly as in data/
Data files can be named anything and placed here just like in data/
Images/sounds/music should be places in their respective subdirs and named identically to the file they
want to replace
A new option mod_order
mod_order is a list of strings, each the name of a mod dir
When the game starts, for each level of data script loading
(engine options, game options, etc.), it first loads the stuff in data/
Then, it loads the corresponding stuff in each mod dir, following the order of mod_order
It uses the system outlined above for overriding
Note that new objects can be created/loaded like this too (not sure if this will help anyone, but)
Thus, the mod that is last on the order list will be loaded last, and anything it overrides will be
the final result for an object
So, mods lower on the list are actually higher priority

For images/music/sounds, it is a bit different
Each asset name must only be loaded once, and there is no overriding/replacing in memory
Instead, the game needs to search all mod dirs (starting at the bottom) and then the data dir for
asset names, and if a name already exists, the new one is ignored
Then, load all of the assets like normal
Thus, assets in the lowest mod on the list (i.e., the highest priority mod) will be loaded instead
of assets in a lower priority mod or the data dir

This system might be a little confusing since data files are loaded from lowest -> highest priority,
overriding previous data stuff, while asset files are looked at from highest -> lowest priority
I think it would be OK, and confusion aside, would be very easy to use
-----------------------------------------------

Write up guidelines for contributors

Write documentation for using the engine, from a non-code standpoint

Move some/all of the ideas and to dos into GitHub issues?

Look into using CMake for my projects
I believe this would entail creating a CMake file that basically
has everything in it that my CodeBlocks project file does currently
Then, it could be used at any time to generate a CodeBlocks project file,
or to instead generate a Makefile
With that working, I could generate and use a Makefile when building on the server,
eliminating the need for CodeBlocks on the server entirely I think, and also
eliminating the need for X11 when building on the server directly

Enable joining a game in progress

Dedicated server mode

IPv6

String data/datafiles
These can be referenced in my other data files in some special way
These can also be referenced in code (this should be really simple to do; look at how colors work?)
Engine needs a language option (this will be a user-configurable option) (defaults to english)
String data entries are now children within a language data entry
When retrieving a string, retrieve the string from the currently set language
With this all setup, this might enable my other idea for making error messages a data file thing
I would also need to extend my stuff to use unicode or whatever instead of just ascii

Change to using dynamic linking instead of static

Maybe all those engine interface functions that return pointers to various objects
should each have an "error" object of the corresponding type that they can return
if they can't find the passed thing
Those objects that are created via scripts could even be hardcoded into the engine, maybe
I could even add a dev option that turns on "crash mode",
and instead of returning error objects, the game just returns null pointers like it does currently

All error messages are located in a script
Would need a new 'error log add' function
that takes an error message name and presents the correct message
Needs to handle an invalid error name
Maybe combine log and error messages into one thing, with a need to specify the type of message

Unit testing for the engine

Other platforms for the Cheese Engine:
BSDs
iOS

Add android mic recording support
Add audio comparison code
Could be used in say bit beast for calling your pet by name

A program that runs in the background (service on android, maybe a regular program on other platforms) that knows where save data is for cheese and bacon games' games
Its purpose would be to detect other instances of the program on other devices
Then it could do street pass like stuff
Of course, this would only be worth it if the devices could detect each other and connect automatically...
A program for all cheese and bacon games, free
Has some kind of currency, earned by simple things like steps taken
Will be cross platform, so I'd prefer to come up with something simple to earn currency on desktop platforms too
Knows where cheese and bacon games are saved on the current platform
What if the user has them elsewhere? Maybe an option to specify the location of various games' save data?
When setting up first time, user creates a profile name
User is assigned randomly generated number. Use some actual real life - based seed, better than just time
These together represent user
User can also set some basic info about them self, and a personal message
Through a connection, the program can detect other instances of itself on other devices
Two instances that see each other do a swap
The program keeps track of what IDs it has swapped with in the past x hours and won't swap with the same ID until the time has passed
Both programs must agree to swap for any data to be exchanged
Both programs agree after swapping of all data is done that it was successful
Only after registering a swap success is any of the swap data actually saved
No record will exist of failed/partial swaps
First, profile data is swapped, including name, message, list of saved games (with swapping permitted), etc.
Keeps a list of all swaps and when they occurred (and if possible maybe even where they occurred?)
Each compatible game has a special save file for this, for swap outgoing
Swapping is enabled on a pergame basis
The swap file contains the permission boolean, along with the game specific data, which is simply swapped out all in one big string
Received swap data for a game is stored in a swap incoming file, inside of a <swap> block
If both programs have a game in common, its data is swapped
